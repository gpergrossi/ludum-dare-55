[gd_scene load_steps=5 format=3 uid="uid://b42t4su0dwe7e"]

[sub_resource type="GDScript" id="GDScript_kqk3v"]
resource_name = "ControlPlayer"
script/source = "extends CharacterBody2D

@export var move_speed = 300.0
@export var jump_velocity = -400.0
@export var coyote_time := 0.250
@export var extra_jumps := 1

# Get the gravity from the project settings to be synced with RigidBody nodes.
var gravity = ProjectSettings.get_setting(\"physics/2d/default_gravity\")

# Record spawn position for respawn logic.
var _spawn_pos : Vector2

# Initial state assumes falling.
var _jumping := false
var _falling := true
var _last_floor_time := 0
var _coyote_jump_used := true
var _extra_jumps_remaining := 0

@onready var height := (find_child(\"CollisionShape2D\").shape as CapsuleShape2D).height

func _ready():
	_spawn_pos = position


func _physics_process(delta: float):
	var space_state = get_world_2d().direct_space_state
	
	# Add the gravity.
	if not is_on_floor():
		# Apply gravity.
		velocity.y += gravity * delta
		if velocity.y > 0:
			_jumping = false
			_falling = true
	else:
		# On the floor again.
		_jumping = false
		_falling = false
		_coyote_jump_used = false
		_extra_jumps_remaining = extra_jumps
		_last_floor_time = Time.get_ticks_msec()
	
	# Handle jump.
	if Input.is_action_just_pressed(\"jump\"):
		var can_jump := is_on_floor() or (not _coyote_jump_used and (Time.get_ticks_msec() - _last_floor_time < (1000 * coyote_time)))
		var can_extra_jump := _extra_jumps_remaining > 0
		if can_jump or can_extra_jump:
			velocity.y = jump_velocity
			_jumping = true
			_coyote_jump_used = true
		if not can_jump and can_extra_jump:
			_extra_jumps_remaining -= 1
			print(\"Extra jump used. Remaining: \" + str(_extra_jumps_remaining))
	
	# Determine floor slope
	if not _jumping and not _falling:
		var slope = try_sample_slope(space_state)
	
	# Get the input direction and handle the movement/deceleration.
	var direction = Input.get_axis(\"move_left\", \"move_right\")
	if direction:
		velocity.x = direction * move_speed
	else:
		velocity.x = move_toward(velocity.x, 0, move_speed)
	
	# Let the physics engine process movement and collisions for this frame.
	move_and_slide()


func _on_kill_zone_body_entered(body):
	if body != self: return
	position = _spawn_pos


func try_sample_slope(space_state : PhysicsDirectSpaceState2D) -> float:
	const epsilon := 5.0
	var left_pos := global_position + Vector2.LEFT * epsilon
	var right_pos := global_position + Vector2.RIGHT * epsilon
	var ray := Vector2.DOWN * (floor_snap_length + 0.5 * height)
	
	var ray_left := PhysicsRayQueryParameters2D.create(left_pos, left_pos + ray)
	var ray_right := PhysicsRayQueryParameters2D.create(right_pos, right_pos + ray)
	var result_left := space_state.intersect_ray(ray_left)
	var result_right := space_state.intersect_ray(ray_right)
	
	if not result_left.is_empty() and not result_right.is_empty():
		var pos_left := result_left[\"position\"] as Vector2
		var pos_right := result_right[\"position\"] as Vector2
		return (pos_right.y - pos_left.y) / (pos_right.x - pos_left.x)
	
	return 0.0
	
"

[sub_resource type="CapsuleShape2D" id="CapsuleShape2D_ku85h"]

[sub_resource type="StandardMaterial3D" id="StandardMaterial3D_lpldx"]
shading_mode = 0
albedo_color = Color(0.627451, 0, 0, 1)

[sub_resource type="CapsuleMesh" id="CapsuleMesh_86ssg"]
material = SubResource("StandardMaterial3D_lpldx")
radius = 10.0
height = 30.0

[node name="CharacterBody2D" type="CharacterBody2D"]
floor_constant_speed = true
floor_snap_length = 11.1
script = SubResource("GDScript_kqk3v")
coyote_time = 0.1

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("CapsuleShape2D_ku85h")

[node name="Player" type="MeshInstance2D" parent="."]
mesh = SubResource("CapsuleMesh_86ssg")

[node name="Camera2D" type="Camera2D" parent="."]
position_smoothing_enabled = true
editor_draw_screen = false
editor_draw_limits = true
